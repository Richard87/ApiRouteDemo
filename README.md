# Api Route

Inspired by the amazing API-Platform, I want a simple Attribute that will introspect the referenced inputs,outputs and
controllers to build a performant OpenAPI schema, with minimal conguration and code.

Includes SwaggerUI, OpenAPI Spec generation, simple Attributes to define your api (Create, Get, Update, Delete, Action,
Collection and Property)

## Goals:

- Simple to use
- Performant
- Produces good autogenerated documentation
- **Generates front-end code with types to access the API**
- A tool to warn if front-end specification will fail against back-end api.

## TODO:

- [X] Register Symfony routes
- [ ] Map all input and output resources, collection yes/no
  - [ ] Include PHPDocs specification for more information
  - [ ] Collection input/output?
  - [ ] Inputs
  - [ ] Outputs
- [ ] Build controllers for standard features
      Possibly by using symfony events to transform data?
    - [ ] Message handlers
    - [ ] Object calls (properties and methods)
    - [ ] Rest endpoints

- [ ] Build OpenAPI Spec
- [ ] Build step for Symfony container builder
- [ ] Tests to validate that everything works
- [ ] Good error messages for bad configuration / (de)serialization errors

```
Class attributes:
- #[Collection] // List all items in a collection
- #[Get] // Get an Item
- #[Create] // Create a new Item in a collection
- #[Update] // Json Merge or Json Patch feature
- #[Delete] // Delete an item from a collection
- #[Action] // Easy specify actions on a item or a collection, either on a Controller, or as a Message

Method attributes:
- #[Collection] // List all items in a items-collection
- #[Action] // Easy specify actions on a item or a collection, either on a Controller, or as a Message
- #[Property] attribute that means the property(or method) should be serialized.
```

All attributes will support Name, path and security arguments to controll access and visibility of the content Global
defaults, like all objects/entities in a path should get List,Get and default security values.

Build as much as possible on top of existing Symfony and Doctrine tools. All collections based on Doctrine will support
filters

A Metadata cache strategy A Request Cache strategy, an invalidation strategy, and vary headers. Documentation Data
transformers? convert IRI to requested Objects

Make sure its performant and not bloated. Cache metadata and se how property access can be efficient

## Questions...

- Difference between CRUD actions, and regular Action, and Collection
- Difference between Item Action and Collection Action /api/users/invite and /api/users/{id}/invite
- ... Maybe everything is a Operation?
- Property attribute or Context groups for serialization...Ìƒ or Both for flexibility?
- Should we set Attributes on public methods/getters, or support properties like API-Platform and guess which getter to
  use?

## Milestones:

- Write spec/req for all attributes
- Create all attributes
- Register routes
- Generate openapi spec
- Swagger UI
- Data transformers / make routes *work*
- Metadata cache
- Request cache strategy
- Filters